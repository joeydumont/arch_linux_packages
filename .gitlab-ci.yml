stages:
  - image
  - check

build_image:
  stage: image
  image: moby/buildkit:rootless
  variables:
    BUILDKITD_FLAGS: --oci-worker-no-process-sandbox
  before_script:
    - mkdir -p ~/.docker
    - echo "{\"auths\":{\"$CI_REGISTRY\":{\"username\":\"$CI_REGISTRY_USER\",\"password\":\"$CI_REGISTRY_PASSWORD\"}}}" > ~/.docker/config.json
  script: >
      buildctl-daemonless.sh build \
        --frontend dockerfile.v0 \
        --local context=. \
        --local dockerfile=Dockerfile.ci \
        --output type=image,name=$CI_REGISTRY_IMAGE:$CI_COMMIT_SHA,push=true
  
rua_check:
  stage: check
  image: ci-base:latest
  script: >
    EXIT_STATUS=0
    while IFS= read -d '' -r pkg; do
      # Emulate rua shellcheck. 
      # We only do this because `rua shellcheck` doesn't allow us to pass options
      # to shellcheck, otherwise we could pass `-S info` to error on info/warnings.
      # `rua shellcheck` also adds lines prior to the start of the PKGBUILD, so the error
      # reporting doesn't have the proper line number.
      echo $pkg
      printf "%s\n%s" "$(cat $pkg/PKGBUILD)" "$(cat PKGBUILD-suffix.sh)" | shellcheck -o=all -e SC2164 -s bash -S info /dev/stdin
      (( EXIT_STATUS |= PIPESTATUS[1] ))
    done < <(find . -mindepth 1 -maxdepth 1 -type d ! -iname '*.git' -print0 | sort -nr)

    while IFS= read -d '' -r script; do
      shellcheck -o=all -S info "$script"
      (( EXIT_STATUS |= $? ))
    done < <(find . -maxdepth 2 -type f ! -iname "PKGBUILD*" -iname "*.sh" -print0)

    exit $EXIT_STATUS

fmt:
  stage: check
  image: ci-base:latest
  script: >
    EXIT_STATUS=0
    while IFS= read -d '' -r script; do 
      shfmt -i 2 -d $script
      (( EXIT_STATUS |= $? ))
    done < <(find . -maxdepth 2 -type f \( -iname "PKGBUILD" -or -iname "*.sh" \) -print0 | sort -nr)

    exit $EXIT_STATUS
      
